name: Build + Publish Debian package and APT repo

on:
  push:
    tags:
      - "v*"

permissions:
  contents: write

env:
  # Publish the same repo layout for multiple Ubuntu releases
  # (for now) just jammy but can be extended as:
  # SUITES: "focal jammy noble"
  SUITES: "jammy"
  COMPONENT: main
  # APT will look for binary-$arch directories. Include the arches you want to support.
  ARCHES: "amd64 arm64"

  # Stable filename that always points to the latest .deb (Pages + Releases)
  STABLE_ASSET_NAME: "eolab-drones-sources_latest.deb"

jobs:
  release:
    runs-on: ubuntu-22.04

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install build + repo tooling
        run: |
          sudo apt-get update
          sudo apt-get install -y --no-install-recommends \
            devscripts debhelper build-essential fakeroot lintian \
            dpkg-dev apt-utils gnupg

      - name: Verify changelog version matches tag
        shell: bash
        run: |
          set -euo pipefail
          TAG="${GITHUB_REF_NAME}"      # vX.Y.Z
          VERSION="${TAG#v}"            # X.Y.Z
          TOPVER="$(dpkg-parsechangelog -SVersion)"

          if [[ "$TOPVER" != "$VERSION" ]]; then
            echo "::error title=Version mismatch,file=debian/changelog::debian/changelog version '$TOPVER' does not match tag '$VERSION' (tag: '$TAG'). Bump debian/changelog (e.g. dch -v '$VERSION') and recreate the tag."
            {
              echo "### ❌ Version mismatch"
              echo ""
              echo "- Tag: \`$TAG\` → expected \`$VERSION\`"
              echo "- debian/changelog: \`$TOPVER\`"
              echo ""
              echo "Fix: bump \`debian/changelog\` to \`$VERSION\` and recreate the tag."
            } >> "$GITHUB_STEP_SUMMARY"
            exit 1
          fi
          echo "::notice title=Version OK::Tag '$TAG' matches debian/changelog '$TOPVER'."

      - name: Build .deb
        shell: bash
        run: |
          set -euo pipefail
          dpkg-buildpackage -b -uc -us
          mkdir -p dist
          cp -v ../*.deb dist/
          ls -lah dist

      - name: Compute filenames
        id: names
        shell: bash
        run: |
          set -euo pipefail
          # Pick the main .deb (avoid dbgsym if present)
          DEB="$(ls dist/*.deb | grep -v 'dbgsym' | head -n 1)"
          if [[ -z "${DEB:-}" ]]; then
            echo "::error title=Build output missing::No .deb produced in dist/"
            exit 1
          fi
          echo "deb_path=$DEB" >> "$GITHUB_OUTPUT"

      # -------------------- GitHub Release (archive + always-latest URL) --------------------
      - name: Create/Update GitHub Release for this tag
        uses: softprops/action-gh-release@v2
        with:
          generate_release_notes: true
          files: |
            ${{ steps.names.outputs.deb_path }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Upload stable-name asset to the tag release (for /releases/latest/download/...)
        shell: bash
        run: |
          set -euo pipefail
          cp -v "${{ steps.names.outputs.deb_path }}" "${{ env.STABLE_ASSET_NAME }}"
          gh release upload "${GITHUB_REF_NAME}" "${{ env.STABLE_ASSET_NAME }}" --clobber
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      # -------------------- Import signing key (ephemeral keyring) --------------------
      - name: Import APT repo signing key
        shell: bash
        run: |
          set -euo pipefail

          export GNUPGHOME="$(mktemp -d)"
          chmod 700 "$GNUPGHOME"
          echo "GNUPGHOME=$GNUPGHOME" >> "$GITHUB_ENV"

          # Import secret key (ASCII-armored)
          echo "${{ secrets.DRONES_GPG_PRIVATE_KEY }}" | gpg --batch --import

          # Trust it for unattended signing
          KEYID="$(gpg --list-secret-keys --with-colons | awk -F: '/^sec:/ {print $5; exit}')"
          if [[ -z "${KEYID:-}" ]]; then
            echo "::error title=GPG key import failed::No secret key found after import."
            exit 1
          fi
          echo "$KEYID:6:" | gpg --batch --import-ownertrust
          echo "APT_SIGNING_KEYID=$KEYID" >> "$GITHUB_ENV"

      # -------------------- Build + sign static APT repo tree --------------------
      - name: Build and sign APT repo (GitHub Pages)
        shell: bash
        env:
          APT_GPG_PASSPHRASE: ${{ secrets.APT_GPG_PASSPHRASE }}
        run: |
          set -euo pipefail

          DEB="${{ steps.names.outputs.deb_path }}"
          OUT="public"

          rm -rf "$OUT"
          mkdir -p "$OUT/pool/${COMPONENT}"

          # Put the .deb in pool/
          cp -v "$DEB" "$OUT/pool/${COMPONENT}/"

          # Also publish a stable "latest" direct-download file on Pages root
          cp -v "$DEB" "$OUT/${STABLE_ASSET_NAME}"

          # Build suite directories and metadata
          pushd "$OUT" >/dev/null

          for SUITE in $SUITES; do
            mkdir -p "dists/${SUITE}/${COMPONENT}"

            # Packages + Packages.gz for each arch
            for A in $ARCHES; do
              DIR="dists/${SUITE}/${COMPONENT}/binary-${A}"
              mkdir -p "$DIR"
              dpkg-scanpackages --arch "$A" pool /dev/null > "${DIR}/Packages"
              gzip -9c "${DIR}/Packages" > "${DIR}/Packages.gz"
            done

            # Release file
            apt-ftparchive \
              -o "APT::FTPArchive::Release::Origin=eolab-hsrw" \
              -o "APT::FTPArchive::Release::Label=drones-sources" \
              -o "APT::FTPArchive::Release::Suite=${SUITE}" \
              -o "APT::FTPArchive::Release::Codename=${SUITE}" \
              -o "APT::FTPArchive::Release::Architectures=${ARCHES}" \
              -o "APT::FTPArchive::Release::Components=${COMPONENT}" \
              -o "APT::FTPArchive::Release::Description=eolab drones sources APT repo" \
              release "dists/${SUITE}" > "dists/${SUITE}/Release"

            # Sign Release → InRelease (clearsigned) + Release.gpg (detached)
            if [[ -n "${APT_GPG_PASSPHRASE:-}" ]]; then
              gpg --batch --yes --pinentry-mode loopback --passphrase "$APT_GPG_PASSPHRASE" \
                --local-user "$APT_SIGNING_KEYID" \
                --clearsign -o "dists/${SUITE}/InRelease" "dists/${SUITE}/Release"
              gpg --batch --yes --pinentry-mode loopback --passphrase "$APT_GPG_PASSPHRASE" \
                --local-user "$APT_SIGNING_KEYID" \
                -abs -o "dists/${SUITE}/Release.gpg" "dists/${SUITE}/Release"
            else
              gpg --batch --yes --local-user "$APT_SIGNING_KEYID" \
                --clearsign -o "dists/${SUITE}/InRelease" "dists/${SUITE}/Release"
              gpg --batch --yes --local-user "$APT_SIGNING_KEYID" \
                -abs -o "dists/${SUITE}/Release.gpg" "dists/${SUITE}/Release"
            fi
          done

          popd >/dev/null

      - name: Deploy APT repo to GitHub Pages (gh-pages)
        uses: peaceiris/actions-gh-pages@v4
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_branch: gh-pages
          publish_dir: public
          force_orphan: true

      - name: Cleanup signing material
        if: always()
        shell: bash
        run: |
          set -euo pipefail
          if [[ -n "${GNUPGHOME:-}" && -d "$GNUPGHOME" ]]; then
            rm -rf "$GNUPGHOME"
          fi

